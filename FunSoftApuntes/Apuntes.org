#+STARTUP: content indent
#+OPTIONS: \n:t
* *Apuntes Fundamentos del Software en Linux*
** Distribucion de la memoria en C
|----------------------------------------------+-----------------------------|
| Argumentos del shell y variables del entorno | \leftarrow *High address*   |
|----------------------------------------------+-----------------------------|
| STACK                                        | \leftarrow Memoria estatica |
|----------------------------------------------+-----------------------------|
| HEAP                                         | \leftarrow Memoria dinamica |
|----------------------------------------------+-----------------------------|
| BSS: Datos no inicializados                  |                             |
|----------------------------------------------+-----------------------------|
| Datos inicializados                          |                             |
|----------------------------------------------+-----------------------------|
| Texto                                        | \leftarrow *Low address*    |
|                                              |                             |
|----------------------------------------------+-----------------------------|
                                   
** Memoria Dinamica y Estatica

*** Repaso rapido de punteros
#+BEGIN_SRC C -n
int *p; // Va al Stack
int x = 10; // Va al Stack
p = &x; // Va al stack. p ahora apunta a x
*p = 20; // Va donde apunta p y asigna 20
printf("%d", x); // Imprime 20
#+END_SRC
    
*** Punteros
**** Punteros en C++
#+BEGIN_SRC C++ -n
int *p = new int; // Va al Stack. Su tamanyo se sabe al compilar
delete p; // Borra p y libera la memoria
const int T = 10;
int *p = new int[T]; // Reserva espacio para 10 enteros
delete []p; // Borra y libera lo anterior
#+END_SRC		      	
**** Punteros en C	       
***** - Con malloc()  
#+BEGIN_SRC C -n		      
int *p = (int *)malloc(sizeof(int)); // Alojamos 1 int
/* Como malloc pide la cantidad d  memoria a reservar y esta
 * varia entre maquinas tenemos que utilizar sizeof() */

#define T 10;
int *q = (int *)malloc(T*sizeof(int)); // Alojamos T ints

#+END_SRC
***** - Con calloc()
malloc() asigna memoria sin quitar la basura. calloc() sin embargo
se encarga de inicializar la memoria a '\0'.

#+BEGIN_SRC C -n
#define T 10;
int *q = (int *)calloc(T,sizeof(int)); // Alojamos T ints
free(q); // Libera la memoria
#+END_SRC

Un ejemplo:

#+BEGIN_SRC C -n
int x = 10; // Stack
int **p; // Stack
p = (int **)malloc(sizeof(int *)); // Heap. Nos devuelve una direccion
                                   // en la que cabe un puntero a int
*p = &x; // Asigna la direccion de x a la zona donde apunta p
/* Tenemos una zona del stack que apunta a heap que apunta a stack
 
      +----------------------+
    x |         10           |<----------+
      |----------------------| 		 |
      |                      | 		 |
      |                      | 		 |
      |       STACK          | 	         |
      |----------------------|	         |
    p |                      |------|    |
      +----------------------+      |    |
      |                      |      |    |
      |       HEAP           |      |    |
      |                      |      |    |
      |----------------------|      |    |
malloc|                      |\ <---+    |
      +----------------------+ \         |
			        \        |
				 --------+
*/   
  **p = 30; // Asignamos 30 a x
//||
//|+------> Va a donde apunta p->Heap
//+--------> Va a donde apunta esa zona de Heap -> x
   
#+END_SRC            
***** Ejemplo de aritmetica con punteros
Ejemplo realizado en clase:
#+BEGIN_SRC C
int a[5];
int *p = a;
*p = 10;
//|     |  0 | 1 | 2 | 3 | 4 |
//|-----+----+---+---+---+---|
//|   a | 10 |   |   |   |   |

p++;
*p = 20;

//|     |  0 |  1 | 2 | 3 | 4 |
//|-----+----+----+---+---+---|
//|   a | 10 | 20 |   |   |   |

p = &a[2];
*p = 30;
p = a + 3;
*p = 40 

//|     |  0 |  1 |  2 |  3 | 4 |
//|-----+----+----+----+----+---|
//|   a | 10 | 20 | 30 | 40 |   |

p = a;
*(p + 4) = 50;
//|     |  0 |  1 |  2 |  3 |  4 |
//|-----+----+----+----+----+----|
//|   a | 10 | 20 | 30 | 40 | 50 |
#+END_SRC
**** Punteros a structs
#+BEGIN_SRC C -n
struct x{
	int dato1;
	int dato2;
};
struct x *p = (struct x *)malloc(sizeof(struct x));
(*p).dato1 = 5;
p->dato2 = 10;
#+END_SRC
**** Punteros a funciones
Son punteros a segmetos del data, que es la parte de la memoria en
la que esta el codigo fuente.
/El nombre de una funcion es un puntero a la zona de memoria donde
esta almacenada dicha funcion./
Ejemplo: 
#+BEGIN_SRC C -n
int f(int a, int b); // Suma
int g(int a, int b; //Resta

int (*punteroFuncion)(int, int);
/* Estamos declarando un puntero a una funcion en la que entran 2
 * int y devuelve tambien un int. */
punteroFuncion = f;
punteroFuncion(3, 4); // Devuelve 7, ya que apunta a f
punteroFuncion = g;
punteroFuncion(3, 4); // Devuelve -1, ya que apunta a g
#+END_SRC
*** Pasar argumentos a funciones
| Tipo           | C  | C++ | Descripcion                       |
|----------------+----+-----+-----------------------------------|
| Por valor      | Si | Si  | Copia la variable y pasa la copia |
| Por referencia | No | Si  | Pasa la variable                  |
| Por direccion  | Si | Si  | Pasa un puntero a la variable     |
|----------------+----+-----+-----------------------------------|

**** Ejemplo por valor
#+BEGIN_SRC C -n
void doble(int i){
	i = i + i;
}
int main() {
	int x = 5;
	doble(x); // Manda una copia de x a doble
	printf("%d", x); // Imprime 5
}
#+END_SRC
**** Ejemplo por referencia
Solo en C++
#+BEGIN_SRC C -n
void doble(int &i){
	i = i + i;
}

int main(){
	int x = 5;
	doble(x);
	printf("%d", x); // Imprime 5
}
#+END_SRC

**** Ejemplo por direccion
#+BEGIN_SRC C -n
void doble(int *i){ // Entra un puntero
 	*i = (*i) + (*i);
} 
int main(){
	int x = 5;
	doble(&x);
	printf("%d", x); // Imprime 10
}
#+END_SRC

Otro ejemplo:

#+BEGIN_SRC C -n
void asignar(**i){
	*i = (int **)malloc(sizeof(int x)); // Asigna memoria en Heap
	**i = 7;
}

int main(){
	int *x;
	doble(&x);
	printf("%d",x); // Imprime 7
	free(x); // Liberamos memoria
}
#+END_SRC
**** Array como argumento

En C, el paso como argumento de un array es un puntero a la primera posicion del array.
El identificador de un array es un puntero constante a la primera pos del mismo.
Ejemplo:
#+BEGIN_SRC C -n
int a[3];

void f(int *a);
void f(int a[]);
//Ambas maneras de declarar la funcion son correctas

f(a); // Entra por valor
#+END_SRC
